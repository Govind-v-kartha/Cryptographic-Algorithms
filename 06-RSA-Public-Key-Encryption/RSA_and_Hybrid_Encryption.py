# -*- coding: utf-8 -*-
"""Welcome To Colab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb

1. RSA Key Generation (PEM format)
"""

# Install: pip install pycryptodome
from Crypto.PublicKey import RSA
import os

def generate_rsa_keypair(name: str, key_size=2048):
    key = RSA.generate(key_size)
    private_key = key.export_key()
    public_key = key.publickey().export_key()

    with open(f"keys/{name}_private.pem", "wb") as priv_file:
        priv_file.write(private_key)
    with open(f"keys/{name}_public.pem", "wb") as pub_file:
        pub_file.write(public_key)

def load_rsa_key(name: str, is_private: bool):
    filename = f"keys/{name}_{'private' if is_private else 'public'}.pem"
    with open(filename, "rb") as key_file:
        return RSA.import_key(key_file.read())

"""2. Session Key Generation & RSA Encryption"""

from Crypto.Cipher import PKCS1_OAEP
from Crypto.Random import get_random_bytes

def generate_session_key(length=16):  # 128-bit
    return get_random_bytes(length)

def encrypt_session_key(session_key: bytes, public_key: RSA.RsaKey):
    cipher = PKCS1_OAEP.new(public_key)
    return cipher.encrypt(session_key)

def decrypt_session_key(encrypted_key: bytes, private_key: RSA.RsaKey):
    cipher = PKCS1_OAEP.new(private_key)
    return cipher.decrypt(encrypted_key)

"""3. AES Encryption/Decryption with CBC"""

from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad

def aes_encrypt(plaintext: bytes, key: bytes):
    iv = get_random_bytes(16)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    ciphertext = cipher.encrypt(pad(plaintext, AES.block_size))
    return iv, ciphertext

def aes_decrypt(ciphertext: bytes, key: bytes, iv: bytes):
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = unpad(cipher.decrypt(ciphertext), AES.block_size)
    return plaintext

"""4. HMAC with SHA-256"""

import hmac
import hashlib

def generate_hmac(message: bytes, key: bytes):
    return hmac.new(key, message, hashlib.sha256).digest()

def verify_hmac(message: bytes, received_hmac: bytes, key: bytes):
    expected_hmac = generate_hmac(message, key)
    return hmac.compare_digest(received_hmac, expected_hmac)

"""5. Chat Simulation"""

def simulate_message_exchange(sender: str, receiver: str, plaintext: str):
    # Load RSA keys
    sender_private = load_rsa_key(sender, True)
    receiver_public = load_rsa_key(receiver, False)

    # Generate and exchange session key
    session_key = generate_session_key()
    encrypted_session_key = encrypt_session_key(session_key, receiver_public)
    print(f"{sender} â†’ {receiver}: [Encrypted Session Key]")

    # Encrypt message
    iv, ciphertext = aes_encrypt(plaintext.encode(), session_key)

    # Generate HMAC
    hmac_tag = generate_hmac(ciphertext, session_key)

    # Simulate Bob decrypting
    receiver_private = load_rsa_key(receiver, True)
    decrypted_key = decrypt_session_key(encrypted_session_key, receiver_private)
    if decrypted_key != session_key:
        print("Key exchange failed!")
        return

    # Verify HMAC
    if not verify_hmac(ciphertext, hmac_tag, decrypted_key):
        print("Message integrity check failed!")
        return

    decrypted_message = aes_decrypt(ciphertext, decrypted_key, iv)
    print(f"{receiver} received: {decrypted_message.decode()}")

"""6. Tampering Detection Test"""

def simulate_tampering(ciphertext: bytes):
    tampered = bytearray(ciphertext)
    tampered[0] ^= 0xFF  # Flip a bit
    return bytes(tampered)

"""Example Execution"""

if __name__ == "__main__":
    os.makedirs("keys", exist_ok=True)
    generate_rsa_keypair("alice")
    generate_rsa_keypair("bob")

    simulate_message_exchange("alice", "bob", "Hello Bob! This is Alice.")

    # Tampering test
    print("\n--- Tampering Simulation ---")
    session_key = generate_session_key()
    iv, ciphertext = aes_encrypt(b"Tamper me!", session_key)
    tampered = simulate_tampering(ciphertext)
    hmac_tag = generate_hmac(ciphertext, session_key)
    print("Integrity check (should fail):", verify_hmac(tampered, hmac_tag, session_key))
