# -*- coding: utf-8 -*-
"""Welcome To Colab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb

Task 1: Implement El Gamal Encryption and Decryption
- Implement El Gamal encryption and decryption using Python.
- Encrypt a given plaintext using randomly generated keys.
- Decrypt the ciphertext to verify correctness.
- Compare encryption and decryption times for different message sizes.
"""

import random
import time

# Function to compute (base^exp) % mod efficiently
def mod_exp(base, exp, mod):
    result = 1
    base = base % mod
    while exp > 0:
        if exp % 2 == 1:
            result = (result * base) % mod
        exp = exp >> 1
        base = (base * base) % mod
    return result

# Function to find a primitive root for prime p
def find_primitive_root(p):
    for g in range(2, p):
        powers = set(mod_exp(g, i, p) for i in range(1, p))
        if len(powers) == p - 1:
            return g
    return None

# ElGamal Key Generation
def generate_keys():
    p = 104729  # Using a large prime number
    g = find_primitive_root(p)
    x = random.randint(1, p - 2)  # Private key
    y = mod_exp(g, x, p)  # Public key
    return p, g, x, y

# ElGamal Encryption
def encrypt(p, g, y, m):
    k = random.randint(1, p - 2)  # Random session key
    c1 = mod_exp(g, k, p)
    s = mod_exp(y, k, p)
    c2 = (m * s) % p
    return c1, c2

# ElGamal Decryption
def decrypt(p, x, c1, c2):
    s = mod_exp(c1, x, p)
    s_inv = pow(s, -1, p)  # Modular inverse of shared secret
    m = (c2 * s_inv) % p
    return m

# Function to measure time taken for encryption & decryption
def test_performance(message_sizes):
    p, g, x, y = generate_keys()
    for size in message_sizes:
        m = random.randint(1, p - 1)  # Plaintext must be smaller than p

        # Encrypt
        start_encrypt = time.time()
        c1, c2 = encrypt(p, g, y, m)
        end_encrypt = time.time()

        # Decrypt
        start_decrypt = time.time()
        decrypted_m = decrypt(p, x, c1, c2)
        end_decrypt = time.time()

        assert decrypted_m == m, f"Decryption failed for message size {size}!"

        print(f"Message Size: {size} bits")
        print(f"Encryption Time: {end_encrypt - start_encrypt:.8f} seconds")
        print(f"Decryption Time: {end_decrypt - start_decrypt:.8f} seconds\n")

def main():
    sizes = input("Enter message sizes separated by commas (e.g., 16,32,64): ")
    message_sizes = list(map(int, sizes.split(',')))
    test_performance(message_sizes)

main()

"""Task 2: Key Sensitivity Analysis

- Encrypt a fixed message using different keys with minor variations.
- Observe the changes in ciphertext to study key sensitivity.
- Measure bitwise differences between different ciphertexts.
"""

# ElGamal Key Generation
def generate_keys():
    p = 104729  # Using a large prime number
    g = find_primitive_root(p)
    x = random.randint(1, p - 2)  # Private key
    y = mod_exp(g, x, p)  # Public key
    return p, g, x, y

# ElGamal Encryption
def encrypt(p, g, y, m):
    k = random.randint(1, p - 2)  # Random session key
    c1 = mod_exp(g, k, p)
    s = mod_exp(y, k, p)
    c2 = (m * s) % p
    return c1, c2

# ElGamal Decryption
def decrypt(p, x, c1, c2):
    s = mod_exp(c1, x, p)
    s_inv = pow(s, -1, p)  # Modular inverse of shared secret
    m = (c2 * s_inv) % p
    return m

# Function to measure time taken for encryption & decryption
def test_performance(message_sizes):
    p, g, x, y = generate_keys()
    for size in message_sizes:
        m = random.randint(1, p - 1)  # Plaintext must be smaller than p

        # Encrypt
        start_encrypt = time.time()
        c1, c2 = encrypt(p, g, y, m)
        end_encrypt = time.time()

        # Decrypt
        start_decrypt = time.time()
        decrypted_m = decrypt(p, x, c1, c2)
        end_decrypt = time.time()

        assert decrypted_m == m, f"Decryption failed for message size {size}!"

        print(f"Message Size: {size} bits")
        print(f"Encryption Time: {end_encrypt - start_encrypt:.8f} seconds")
        print(f"Decryption Time: {end_decrypt - start_decrypt:.8f} seconds\n")

# Task 2: Key Sensitivity Analysis
def bit_difference(a, b):
    """Calculate the number of differing bits between two integers."""
    return bin(a ^ b).count('1')

def key_sensitivity_test():
    p = 104729  # Large prime number
    g = find_primitive_root(p)

    fixed_message = random.randint(1, p - 1)
    print(f"Fixed Message: {fixed_message}")

    x1 = random.randint(1, p - 2)
    y1 = mod_exp(g, x1, p)
    c1_1, c2_1 = encrypt(p, g, y1, fixed_message)

    # Slight variation in private key
    x2 = x1 + 1 if x1 + 1 < p - 1 else x1 - 1
    y2 = mod_exp(g, x2, p)
    c1_2, c2_2 = encrypt(p, g, y2, fixed_message)

    # Calculate and display bit differences
    c1_diff = bit_difference(c1_1, c1_2)
    c2_diff = bit_difference(c2_1, c2_2)

    print("Key Sensitivity Analysis:")
    print(f"Original Private Key: {x1}, Modified Private Key: {x2}")
    print(f"Original Ciphertext: c1={c1_1}, c2={c2_1}")
    print(f"Modified Ciphertext: c1={c1_2}, c2={c2_2}")
    print(f"Bit Difference in c1: {c1_diff}")
    print(f"Bit Difference in c2: {c2_diff}")

# Main Execution
def main():
    message_sizes = [16, 32, 64, 128, 256]  # Simulated sizes
    test_performance(message_sizes)
    key_sensitivity_test()

main()

"""Task 3: Plaintext Sensitivity Analysis
- Encrypt multiple messages with minor variations using a fixed key.
- Compare ciphertexts and analyze the impact of plaintext modifications.
"""

import random
import time

# Function to compute (base^exp) % mod efficiently
def mod_exp(base, exp, mod):
    result = 1
    base = base % mod
    while exp > 0:
        if exp % 2 == 1:
            result = (result * base) % mod
        exp = exp >> 1
        base = (base * base) % mod
    return result

# Function to find a primitive root for prime p
def find_primitive_root(p):
    for g in range(2, p):
        powers = set(mod_exp(g, i, p) for i in range(1, p))
        if len(powers) == p - 1:
            return g
    return None

# ElGamal Key Generation
def generate_keys():
    p = 104729  # Using a large prime number
    g = find_primitive_root(p)
    x = random.randint(1, p - 2)  # Private key
    y = mod_exp(g, x, p)  # Public key
    return p, g, x, y

# ElGamal Encryption
def encrypt(p, g, y, m):
    k = random.randint(1, p - 2)  # Random session key
    c1 = mod_exp(g, k, p)
    s = mod_exp(y, k, p)
    c2 = (m * s) % p
    return c1, c2

# ElGamal Decryption
def decrypt(p, x, c1, c2):
    s = mod_exp(c1, x, p)
    s_inv = pow(s, -1, p)  # Modular inverse of shared secret
    m = (c2 * s_inv) % p
    return m

# Function to measure time taken for encryption & decryption
def test_performance(message_sizes):
    p, g, x, y = generate_keys()
    for size in message_sizes:
        m = random.randint(1, p - 1)  # Plaintext must be smaller than p

        # Encrypt
        start_encrypt = time.time()
        c1, c2 = encrypt(p, g, y, m)
        end_encrypt = time.time()

        # Decrypt
        start_decrypt = time.time()
        decrypted_m = decrypt(p, x, c1, c2)
        end_decrypt = time.time()

        assert decrypted_m == m, f"Decryption failed for message size {size}!"

        print(f"Message Size: {size} bits")
        print(f"Encryption Time: {end_encrypt - start_encrypt:.8f} seconds")
        print(f"Decryption Time: {end_decrypt - start_decrypt:.8f} seconds\n")

# Task 2: Key Sensitivity Analysis
def bit_difference(a, b):
    """Calculate the number of differing bits between two integers."""
    return bin(a ^ b).count('1')

def key_sensitivity_test():
    p = 104729  # Large prime number
    g = find_primitive_root(p)

    fixed_message = random.randint(1, p - 1)
    print(f"Fixed Message: {fixed_message}")

    x1 = random.randint(1, p - 2)
    y1 = mod_exp(g, x1, p)
    c1_1, c2_1 = encrypt(p, g, y1, fixed_message)

    # Slight variation in private key
    x2 = x1 + 1 if x1 + 1 < p - 1 else x1 - 1
    y2 = mod_exp(g, x2, p)
    c1_2, c2_2 = encrypt(p, g, y2, fixed_message)

    # Calculate and display bit differences
    c1_diff = bit_difference(c1_1, c1_2)
    c2_diff = bit_difference(c2_1, c2_2)

    print("Key Sensitivity Analysis:")
    print(f"Original Private Key: {x1}, Modified Private Key: {x2}")
    print(f"Original Ciphertext: c1={c1_1}, c2={c2_1}")
    print(f"Modified Ciphertext: c1={c1_2}, c2={c2_2}")
    print(f"Bit Difference in c1: {c1_diff}")
    print(f"Bit Difference in c2: {c2_diff}")

# Task 3: Plaintext Sensitivity Analysis
def plaintext_sensitivity_test():
    p, g, x, y = generate_keys()

    base_message = random.randint(1, p - 10)
    variations = [base_message + i for i in range(5)]

    ciphertexts = []

    print("\nPlaintext Sensitivity Analysis:")
    for msg in variations:
        c1, c2 = encrypt(p, g, y, msg)
        ciphertexts.append((c1, c2))
        print(f"Message: {msg} -> Ciphertext: c1={c1}, c2={c2}")

    # Compare bitwise differences
    for i in range(len(ciphertexts) - 1):
        c1_diff = bit_difference(ciphertexts[i][0], ciphertexts[i + 1][0])
        c2_diff = bit_difference(ciphertexts[i][1], ciphertexts[i + 1][1])
        print(f"Between Message {variations[i]} and {variations[i + 1]}:")
        print(f"Bit Difference in c1: {c1_diff}")
        print(f"Bit Difference in c2: {c2_diff}\n")

# Main Execution
def main():
    message_sizes = [16, 32, 64, 128, 256]  # Simulated sizes
    test_performance(message_sizes)
    key_sensitivity_test()
    plaintext_sensitivity_test()

main()

"""Task 4: Security Analysis and Report
- Conduct a statistical analysis of ciphertexts for randomness.
- Evaluate encryption and decryption time with varying message lengths.
- Discuss the mathematical assumptions behind El Gamal&#39;s security.
- Compare El Gamal with RSA and ECC in terms of security and efficiency.
"""

import random
import time

# Function to compute (base^exp) % mod efficiently
def mod_exp(base, exp, mod):
    result = 1
    base = base % mod
    while exp > 0:
        if exp % 2 == 1:
            result = (result * base) % mod
        exp = exp >> 1
        base = (base * base) % mod
    return result

# Function to find a primitive root for prime p
def find_primitive_root(p):
    for g in range(2, p):
        powers = set(mod_exp(g, i, p) for i in range(1, p))
        if len(powers) == p - 1:
            return g
    return None

# ElGamal Key Generation
def generate_keys():
    p = 104729  # Using a large prime number
    g = find_primitive_root(p)
    x = random.randint(1, p - 2)  # Private key
    y = mod_exp(g, x, p)  # Public key
    return p, g, x, y

# ElGamal Encryption
def encrypt(p, g, y, m):
    k = random.randint(1, p - 2)  # Random session key
    c1 = mod_exp(g, k, p)
    s = mod_exp(y, k, p)
    c2 = (m * s) % p
    return c1, c2

# ElGamal Decryption
def decrypt(p, x, c1, c2):
    s = mod_exp(c1, x, p)
    s_inv = pow(s, -1, p)  # Modular inverse of shared secret
    m = (c2 * s_inv) % p
    return m

# Function to measure time taken for encryption & decryption
def test_performance(message_sizes):
    p, g, x, y = generate_keys()
    for size in message_sizes:
        m = random.randint(1, p - 1)  # Plaintext must be smaller than p

        start_encrypt = time.time()
        c1, c2 = encrypt(p, g, y, m)
        end_encrypt = time.time()

        start_decrypt = time.time()
        decrypted_m = decrypt(p, x, c1, c2)
        end_decrypt = time.time()

        assert decrypted_m == m, f"Decryption failed for message size {size}!"

        print(f"Message Size: {size} bits")
        print(f"Encryption Time: {end_encrypt - start_encrypt:.8f} seconds")
        print(f"Decryption Time: {end_decrypt - start_decrypt:.8f} seconds\n")

# Task 2: Key Sensitivity Analysis
def bit_difference(a, b):
    """Calculate the number of differing bits between two integers."""
    return bin(a ^ b).count('1')

def key_sensitivity_test():
    p = 104729
    g = find_primitive_root(p)

    fixed_message = random.randint(1, p - 1)
    print(f"Fixed Message: {fixed_message}")

    x1 = random.randint(1, p - 2)
    y1 = mod_exp(g, x1, p)
    c1_1, c2_1 = encrypt(p, g, y1, fixed_message)

    x2 = x1 + 1 if x1 + 1 < p - 1 else x1 - 1
    y2 = mod_exp(g, x2, p)
    c1_2, c2_2 = encrypt(p, g, y2, fixed_message)

    c1_diff = bit_difference(c1_1, c1_2)
    c2_diff = bit_difference(c2_1, c2_2)

    print("Key Sensitivity Analysis:")
    print(f"Original Private Key: {x1}, Modified Private Key: {x2}")
    print(f"Original Ciphertext: c1={c1_1}, c2={c2_1}")
    print(f"Modified Ciphertext: c1={c1_2}, c2={c2_2}")
    print(f"Bit Difference in c1: {c1_diff}")
    print(f"Bit Difference in c2: {c2_diff}")

# Task 3: Plaintext Sensitivity Analysis
def plaintext_sensitivity_test():
    p, g, x, y = generate_keys()

    base_message = random.randint(1, p - 10)
    variations = [base_message + i for i in range(5)]

    ciphertexts = []

    print("\nPlaintext Sensitivity Analysis:")
    for msg in variations:
        c1, c2 = encrypt(p, g, y, msg)
        ciphertexts.append((c1, c2))
        print(f"Message: {msg} -> Ciphertext: c1={c1}, c2={c2}")

    for i in range(len(ciphertexts) - 1):
        c1_diff = bit_difference(ciphertexts[i][0], ciphertexts[i + 1][0])
        c2_diff = bit_difference(ciphertexts[i][1], ciphertexts[i + 1][1])
        print(f"Between Message {variations[i]} and {variations[i + 1]}:")
        print(f"Bit Difference in c1: {c1_diff}")
        print(f"Bit Difference in c2: {c2_diff}\n")

# Task 4: Security Analysis and Report
def statistical_randomness_test():
    p, g, x, y = generate_keys()
    samples = 1000
    c1_values = []
    c2_values = []

    for _ in range(samples):
        m = random.randint(1, p - 1)
        c1, c2 = encrypt(p, g, y, m)
        c1_values.append(c1 % 2)
        c2_values.append(c2 % 2)

    c1_ones = sum(c1_values)
    c2_ones = sum(c2_values)
    print("\nStatistical Randomness Test:")
    print(f"c1 bit distribution: {c1_ones} ones, {samples - c1_ones} zeros")
    print(f"c2 bit distribution: {c2_ones} ones, {samples - c2_ones} zeros")

    if abs(c1_ones - samples/2) < samples * 0.05 and abs(c2_ones - samples/2) < samples * 0.05:
        print("Ciphertext passes randomness test.")
    else:
        print("Ciphertext shows potential bias.")

# Theory Discussion
def security_theory_discussion():
    print("\nSecurity Theory Discussion:")
    print("ElGamal relies on the hardness of the Discrete Logarithm Problem.")
    print("This means: Given g, p, and g^x mod p, computing x is infeasible for large primes.")
    print("Compared to RSA (based on integer factorization) and ECC (Elliptic Curve Discrete Log), ElGamal offers probabilistic encryption for better semantic security but usually longer ciphertexts.")

# Main Execution
def main():
    message_sizes = [16, 32, 64, 128, 256]
    test_performance(message_sizes)
    key_sensitivity_test()
    plaintext_sensitivity_test()
    statistical_randomness_test()
    security_theory_discussion()

main()